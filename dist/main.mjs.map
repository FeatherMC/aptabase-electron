{"version":3,"sources":["../src/main.ts","../src/lib/env.ts","../src/lib/session.ts"],"sourcesContent":["import { app, ipcMain, net, protocol } from \"electron\";\nimport { EnvironmentInfo, getEnvironmentInfo } from \"./lib/env\";\nimport { newSessionId } from \"./lib/session\";\n\nexport type AptabaseOptions = {\n  host?: string;\n};\n\n// Session expires after 1 hour of inactivity\nconst SESSION_TIMEOUT = 1 * 60 * 60;\nlet _sessionId = newSessionId();\nlet _lastTouched = new Date();\nlet _appKey = \"\";\nlet _apiUrl = \"\";\nlet _env: EnvironmentInfo | undefined;\n\nconst _hosts: { [region: string]: string } = {\n  US: \"https://us.aptabase.com\",\n  EU: \"https://eu.aptabase.com\",\n  DEV: \"http://localhost:3000\",\n  SH: \"\",\n};\n\nexport async function initialize(\n  appKey: string,\n  options?: AptabaseOptions\n): Promise<void> {\n  if (app.isReady()) {\n    console.warn(\n      \"Aptabase: `initialize` must be invoked before the app is ready. Tracking will be disabled.\"\n    );\n    return;\n  }\n\n  const parts = appKey.split(\"-\");\n  if (parts.length !== 3 || _hosts[parts[1]] === undefined) {\n    console.warn(\n      `Aptabase: App Key \"${appKey}\" is invalid. Tracking will be disabled.`\n    );\n    return;\n  }\n\n  registerAptabaseProtocol();\n  await app.whenReady();\n\n  registerEventHandler();\n\n  const baseUrl = getBaseUrl(parts[1], options);\n  _apiUrl = `${baseUrl}/api/v0/event`;\n  _env = await getEnvironmentInfo(app);\n  _appKey = appKey;\n\n  // some events might be emitted before the initialization is complete\n  // so we drain the buffer here\n  drainBuffer();\n}\n\nconst buffer: {\n  eventName: string;\n  props?: Record<string, string | number | boolean>;\n}[] = [];\n\nexport function trackEvent(\n  eventName: string,\n  props?: Record<string, string | number | boolean>\n): Promise<void> {\n  if (!_appKey || !_env) {\n    buffer.push({ eventName, props });\n    return Promise.resolve();\n  }\n\n  let now = new Date();\n  /*\n  const diffInMs = now.getTime() - _lastTouched.getTime();\n  const diffInSec = Math.floor(diffInMs / 1000);\n  if (diffInSec > SESSION_TIMEOUT) {\n    _sessionId = newSessionId();\n  }*/\n  _lastTouched = now;\n\n  const body = {\n    timestamp: now.toISOString(),\n    sessionId: _sessionId,\n    eventName: eventName,\n    systemProps: {\n      isDebug: _env.isDebug,\n      locale: _env.locale,\n      osName: _env.osName,\n      osVersion: _env.osVersion,\n      engineName: _env.engineName,\n      engineVersion: _env.engineVersion,\n      appVersion: _env.appVersion,\n      sdkVersion: _env.sdkVersion,\n    },\n    props: props,\n  };\n\n  return new Promise((resolve) => {\n    const onReject = (err: Error) => {\n      console.error(`Aptabase: Failed to send event`, err);\n      resolve();\n    };\n\n    const req = net.request({\n      method: \"POST\",\n      url: _apiUrl,\n      credentials: \"omit\",\n    });\n\n    req.setHeader(\"Content-Type\", \"application/json\");\n    req.setHeader(\"App-Key\", _appKey);\n\n    req.on(\"error\", onReject);\n    req.on(\"abort\", onReject);\n    req.on(\"response\", (res) => {\n      if (res.statusCode >= 300) {\n        console.warn(\n          `Aptabase: Failed to send event \"${eventName}\": ${res.statusCode} ${res.statusMessage}`\n        );\n      }\n      resolve();\n    });\n\n    req.write(JSON.stringify(body));\n    req.end();\n  });\n}\n\nfunction drainBuffer() {\n  while (buffer.length > 0) {\n    const data = buffer.shift();\n    if (data) {\n      trackEvent(data.eventName, data.props);\n    }\n  }\n}\n\nfunction registerAptabaseProtocol() {\n  if (!protocol.registerSchemesAsPrivileged) return;\n\n  protocol.registerSchemesAsPrivileged([\n    {\n      scheme: \"aptabase-ipc\",\n      privileges: {\n        bypassCSP: true,\n        corsEnabled: true,\n        supportFetchAPI: true,\n        secure: true,\n      },\n    },\n  ]);\n}\n\nfunction registerEventHandler() {\n  ipcMain.on(\n    \"aptabase:trackEvent\",\n    (\n      _event,\n      eventName: string,\n      props?: Record<string, string | number | boolean>\n    ) => {\n      trackEvent(eventName, props).catch((err) => {\n        console.error(\"Aptabase: Failed to send event\", err);\n      });\n    }\n  );\n\n  if (!protocol.registerStringProtocol) return;\n  protocol.registerStringProtocol(\"aptabase-ipc\", (request, callback) => {\n    try {\n      const data = request.uploadData?.[0]?.bytes;\n      const { eventName, props } = JSON.parse(data?.toString() ?? \"{}\");\n      trackEvent(eventName, props);\n    } catch (err) {\n      console.error(\"Aptabase: Failed to send event\", err);\n    }\n\n    callback(\"\");\n  });\n}\n\nfunction getBaseUrl(\n  region: string,\n  options?: AptabaseOptions\n): string | undefined {\n  if (region === \"SH\") {\n    if (!options?.host) {\n      console.warn(\n        `Aptabase: Host parameter must be defined when using Self-Hosted App Key. Tracking will be disabled.`\n      );\n      return;\n    }\n    return options.host;\n  }\n\n  return _hosts[region];\n}\n","import { exec } from \"child_process\";\nimport type { App } from \"electron\";\nimport { readFile } from \"fs\";\nimport { release } from \"os\";\n\nconst sdkVersion = `aptabase-electron@${process.env.PKG_VERSION}`;\n\nexport interface EnvironmentInfo {\n  isDebug: boolean;\n  locale: string;\n  appVersion: string;\n  sdkVersion: string;\n  osName: String;\n  osVersion: String;\n  engineName: String;\n  engineVersion: String;\n}\n\nexport async function getEnvironmentInfo(app: App): Promise<EnvironmentInfo> {\n  const [osName, osVersion] = await getOperatingSystem();\n\n  return {\n    appVersion: app.getVersion(),\n    isDebug: !app.isPackaged,\n    locale: app.getLocale(),\n    osName,\n    osVersion,\n    engineName: \"Chromium\",\n    engineVersion: process.versions.chrome,\n    sdkVersion,\n  };\n}\n\nasync function getOperatingSystem(): Promise<[string, string]> {\n  switch (process.platform) {\n    case \"win32\":\n      return [\"Windows\", release()];\n    case \"darwin\":\n      const macOSVersion = await getMacOSVersion();\n      return [\"macOS\", macOSVersion];\n    default:\n      return await getLinuxInfo();\n  }\n}\n\nasync function getMacOSVersion() {\n  try {\n    const output = await new Promise<string>((resolve, reject) => {\n      exec(\n        \"/usr/bin/sw_vers -productVersion\",\n        (error: Error | null, stdout: string) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(stdout);\n        }\n      );\n    });\n    return output.trim();\n  } catch (ex) {\n    return \"\";\n  }\n}\n\nasync function getLinuxInfo(): Promise<[string, string]> {\n  try {\n    const content = await new Promise<string>((resolve, reject) => {\n      readFile(\n        \"/etc/os-release\",\n        \"utf8\",\n        (error: Error | null, output: string) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(output);\n        }\n      );\n    });\n\n    const lines = content.split(\"\\n\");\n    const osData: Record<string, string> = {};\n    for (const line of lines) {\n      const [key, value] = line.split(\"=\");\n      if (key && value) {\n        osData[key] = value.replace(/\"/g, \"\"); // Remove quotes if present\n      }\n    }\n    const osName = osData[\"NAME\"] ?? \"Linux\";\n    const osVersion = osData[\"VERSION_ID\"] ?? \"\";\n    return [osName, osVersion];\n  } catch {\n    return [\"Linux\", \"\"];\n  }\n}\n","export function newSessionId(): string {\n  const epochInSeconds = Math.floor(Date.now() / 1000).toString();\n  const random = Math.floor(Math.random() * 100000000)\n    .toString()\n    .padStart(8, \"0\");\n\n  return epochInSeconds + random;\n}\n"],"mappings":"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","names":["app","ipcMain","net","protocol","exec","readFile","release","sdkVersion","getEnvironmentInfo","app","__async","osName","osVersion","getOperatingSystem","release","getMacOSVersion","getLinuxInfo","resolve","reject","exec","error","stdout","ex","_a","_b","lines","readFile","output","osData","line","key","value","e","newSessionId","epochInSeconds","random","SESSION_TIMEOUT","_sessionId","newSessionId","_lastTouched","_appKey","_apiUrl","_env","_hosts","initialize","appKey","options","__async","app","parts","registerAptabaseProtocol","registerEventHandler","getBaseUrl","getEnvironmentInfo","drainBuffer","buffer","trackEvent","eventName","props","now","body","resolve","onReject","err","req","net","res","data","protocol","ipcMain","_event","request","callback","_a","_b","_c","region"]}